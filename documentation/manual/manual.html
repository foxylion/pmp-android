<!DOCTYPE html>
<html>
<head>
  <title>Handbuch - Privacy Management Platform</title>
  <script type="text/javascript" src="../_layout/jquery-1.6.2.min.js"></script>
  <script type="text/javascript" src="../_layout/script.js"></script>
  <link type="text/css" rel="stylesheet" media="screen" href="../_layout/style.css">
  <link type="text/css" rel="stylesheet" media="print"  href="../_layout/print.css">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
  <div id="wrapper">
    <div id="page-head-date">17. August 2011</div>
    <div id="page-head-title">Privacy Management Platform</div>
    <div id="page-title">Handbuch</div>
    <div id="page-version">Version 0.1</div>
    
    <nav>
      <div class="title">Inhaltsverzeichnis</div>
      <ul>
      </ul>
    </nav>
    
    <!-- here comes the content of the specification -->
    <div id="content">
      
      <h1 id="einleitung">Einleitung</h1>
      
      <h2 id="zweck">Zweck</h2>
      <p>
        Dieses stellt das Handbuch der "Privacy Management Platform". Es soll
        sowohl den Laien als auch den erfahrenen Benutzer und Entwickler bei der
        verwendung der PMP unterstützen. Auf eine gute Verständlichkeit wird
        Wert gelegt.        
      </p>
      
      <h2 id="leserkreis">Leserkreis</h2>
      <p>
        Das Handbuch richtet sich an folgende Lesergruppen:
        <ul>
          <li>den unerfahrenen Benutzer</li>
          <li>den erfahrenen Benutzer</li>
          <li>den Entwicklern von Ressourcen (für die PMP)</li>
          <li>den Entwicklern von APPs inkl. der Service-Levels</li>
          <li>dem Kunden</li>
          <li>den Betreuern des Studienprojekts</li>
        </ul> 
      </p>
      
      
      <h2 id="gliederung">Gliederung</h2>
      <p>
        Der besseren Übersicht wegen unterteil sich das Handbuch in die einzelnen
        Benutzergruppen:
        <ul>
          <li>"<span class="reference" title="#user"></span>" richtet sich an Benutzer,
            die die PMP verwenden möchten. Diese Kapitel unterteilt sich in einen Abschnitt,
            der den einfachen Modus (<span class="reference" title="#simplemode"></span>) 
            erläutert, und einen Abschnitt für den erweiterten Modus 
            (<span class="reference" title="#expertmode"></span>), der die Funktionen des
            erweiterten Modus beschreibt.</li>
          <li>"<span class="reference" title="#developers"></span>" richtet sich an 
            Benutzer, die Ressourcen oder Apps für die PMP entwickel möchten.
            Der Unterabschnitt "<span class="reference" title="#devsl"></span>"
            geht auf die Erstellung und Definition von Service Levels zur integration
            in eigene Apps ein. Dagegen beschriebt 
            "<span class="reference" title="#devres"></span>" wie Ressourcen erstellt
            und in die PMP integriert werden können.
        </ul>
      </p>
      
      <h1 id="user">Anwender</h1>
      <p>
        Dieser Abschnitt richtet sich an die Benutzer der PMP. Die PMP lässt sich in
        zwei Modi betreiben: im einfachen Modus (als Simple Mode bezeichnet), stehen
        dem Benutzer die wichtigsten Funktionen zur Verfügung. Werden alle Funktionen
        benötigt, lässt sich das System in den erweiterten Modus (Expert Mode) schalten.
        
      <h2 id="switchmode">Wechsel zwischen Modis</h2>
      <p>
        Der Wechsel zwischen einfachen und erweiterte Modus erfolgt über die 
        Schalftläche "Expert Mode" auf dem Startbildschirm der PMP.
      </p>
      <p>
        Befindet sich die PMP im erweiterten Modus, erscheint ein Häkchen im vorderen
        Bereich der Schaltfläche. Durch Antippen der Schaltfläche wird zwischen 
        den Modi hin- und hergewächselt.
      </p> 
      
      <h2 id="simplemode">Einfacher Modus (Simple Mode)</h2>
      <p>
        Der einfache Modus ist auf Anwender mit geringen Kenntnissen angepasst.
        Daher enthält er nur die wichtigsten Funktionen um den Benutzer nicht zu 
        überfordern.
      </p>
      
      <h2 id="expertmode">Erweiterter Modus (Expert Mode)</h2>
      <p>
        Der erweiterte Modus gibt Zugriff auf alle Funktionen der PMP. Da sich daher 
        unerfahrene Benutzer überfordert fühlen könnten, richtet sich dieser Modus
        an erfahrene Benutzer, die vollen Zugriff auf den Funktionsumfang haben möchten.
      </p>
      <p>
        Dieser Abschnitt enthält nur die Funktionen, die aussschließlich im erweiterten
        Modus verfügbar sind um redundanz mit dem obigen Abschnitt zu vermeiden
      </p>
      <p>
        Da der erweiterte Modus gegenwärtig nicht implementiert ist, wird auf ihn 
        in dieser Version des Handbuchs nicht näher eingegangen
      </p>
      <h1 id="developers">Entwickler</h1>
      <p>
        Dieser Abschnitt richtet sich an erfahrene Benutzer, die die PMP um eigene
        Ressourcen erweitern oder Anwendungen für die PMP erstellen möchten
      </p>
      
      <h2 id="devsl">Service-Levels</h2>
      <p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</p>
      
      <h2 id="devres">Ressourcen</h2>
      <hr />
      <p><b>Hinweis:</b> Dies nachfolgende Beschreibung habe ich nach betrachten des Codes erstellt.
      Daher kann es sein, dass einige Dinge - z. B. durch Missverständnisse - nicht stimmen.
      Nachdem ich die Dateisystemressource erstellt habe, werde ich diesen Abschnitt
      nochmals überabreiten und mit den Erfahrungen, die ich beim Implementieren gemacht habe,
      vergleichen.
      </p>
      <hr />
      <p>
        Ressourcen bieten Anwendungen Zugriff auf die verschiedenen Funktionen eines
        Android-Gerätes. In der PMP werden einzelne, inhaltlich zusammengehörige 
        Ressourcen in Ressourcengruppen zusammengefasst. Um Ressourcen auf dem Gerät 
        verfügbar machen zu können, müssen diese immer einer Gruppe zugeordnet werden.
      </p>
      <p>
        Das Erstellen einer Ressourcengruppe und deren Ressourcen läuft in folgenden
        Schritten ab:
        <ul>
          <li>Bestimmen und Implementieren einzelner Ressourcen (z.B. jeweils eine 
            Ressource um eine Datei in verschiedenen Bereichen des Geräts zu lesen, 
            schreiben oder zu löschen)</li>
          <li>Festlegen einer Ressourcengruppe (z.B. Dateisystemzugriff) und Hinzufügen 
            der erstellten Ressourcen zu dieser</li>
          <li>Bestimmen und Implementieren der zu der erstellten Ressourcengruppe
            passenden Privacy Levels (z.B. nur lesen, nur schreibe oder lesen und 
            schreiben)</li>
          <li>Hinzufügen der Privacy-Levels zu der Ressourcengruppe</li>
          <li>Implementieren einer Anwendung, die die erstellten Ressourcengruppen 
            enthält.</li>
        </ul>
        In den nachfolgenden Unterabschnitten werden die einzelnen Phasen genauer
        beschrieben und anhand von Beispielen erläutert.<br /> 
        Alle für das Erstellen einer Ressource benötigten Klassen befinden sich im 
        Paket &quot;de.unistuttgart.ipvs.pmp.resource&quot; der API-Bibliothek.<br />
        Der PMP liegen mehrere Beispiel-Ressourcen bei. Diese können als Referenz 
        für das Erstellen eigener Ressourcen verwendet werden.
      </p>
      
      <h3 id="devres_res">Erstellen einer Ressource</h3>
      <p>
        Ressourcen bilden die Grundlage einer Ressourcengruppe. Jede Gruppe benötigt 
        mindestens eine Ressourcen. Die Basisklasse einer Ressource bildet 
        <code>Resource</code>.
        Um eigene Ressourcen zu erstellen, wird diese Erweitert. Anschließend muss 
        die Methode <code>getAndroidInterface()</code> impelementiert werden.
      </p>

      <p>
        Zunächst wird eine AIDL-Interace erstellt, dass die für Anwendungen sichtbaren 
        Funktionen der Ressource beinhaltet (etwa Datei lesen). Nachdem Android aus 
        diesem Interface automatisch ein Stub erstellt hat, wird dieses implementiert, 
        um die Funktionalität der Ressource zu liefern.
        Die Methode <code>getAndroidInterface()</code> liefert nun dieses Interface 
        zurück, um Anwendungen Zugriff auf die Ressource zu bieten. 
        Über den Parameter wird der Name der Anwendung übergeben, die Zugriff auf 
        die Funktionen der Ressource verlangt. Dieser sollte der Implementierung des
        AIDL-Interface weitergereich werden, damit dieses pürfen kann, ob die 
        Anwendung zum Zugriff auf die Funktion berechtigt ist.
      </p>
      
      <h3 id="devres_privlevel">Erstellen eines Privacy-Levels</h3>
      <p>
        Jede Ressourcengruppe behinhaltet mehrere Privacy-Levels. Privay-Levels 
        werden durch erweitern der Klasse &quot;PrivacyLevel&quot; erstellt, wobei 
        alle abstrakten Methoden implementiert werden müssen. Für Privacy-Levels, die als
        Wert nur Wahrheitswerte erlauben, bietet die API mit <code>BooleanPrivacyLevel</code>
        eine fertige Implementierung.
      </p>

      <h4 id="devres_privlevel_boolean">Für Wahrheitswerte</h4>
      <p>
        Bei Verwendung eines <code>BooleanPrivacyLevel</code> empfiehlt es sich,
        den Namen und die Beschreibung des Privacy-Levels in die String-Ressource
        auszulagern.
      </p>
      
<pre>
Resource r = context.getResources();
plOne = new BooleanPrivacyLevel(r.getString(R.string.pl_one), 
          r.getString(R.string.pl_one_desc));
plTwo = new BooleanPrivacyLevel(r.getString(R.string.pl_two), 
          r.getString(R.string.pl_two_desc));
</pre>

      <h4 id="devres_privlevel_userdefined">Benutzerdefiniert</h4>      
      <p>
        Sollte die Erstellung eine benutzerdefiniertes Privacy-Levels erforderlich
        sein, d. h. <code>PrivacyLevel</code> wird erweitert, so müssen einige
        Methoden implementiert werden:
      </p>
      <p>
        Über <code>getName()</code> und <code>getDescription()</code> erhält der 
        Anwender den <b>Namen</b> und die <b>Beschreibung</b> des Privacy-Levels. 
        Beide Methoden erhalten als Parameter das Kürzel der Sprache, in der der 
        jeweilige Wert zurückgegeben werden soll, wobei der Parameter der ISO-639 
        Norm entspricht (z.B. &quot;en&quot; bei englisch, &quot;de&quot; bei deutsch).
        Die Methoden müssen anschließen den zur jeweiligen Sprache gehörenden Wert 
        zurück liefern. Es epmfiehlt sich allerdings den Parameter zu ignorieren
        und stets den entsprechenden Werte aus der String-Ressource zu laden.
      </p>

      <p>
        Über die Methode <code>getHumanReadablePrivacyLevelValue()</code> 
        wird der <b>menschen lesbare Wert eines Privacy-Levels</b> zurückgegeben. 
        Der erste Parameter entspricht dem oben erwähnten Sprachlkürzel.
        Dieser gibt an, in welcher Sprache der Wert zurückgeliefert werden soll. 
        Über den zweiten Wert wird der intern verwendete Wert des Privacy-Levels 
        übergeben. Aus diesen Daten berechnet die Methode den für die Anzeige
        geeigneten Text (z. B. wird aus dem internen Wert "r" und der gewählten 
        Sprache "de" der Text "lesen" berechnet und zurückgegeben).
        Wie bereits oben erwähnte, empfiehlt es sich auch hier, die String-Ressourcen
        zu verwenden.
      </p>
        
<pre>
  public String getHumanReadablePrivacyLevelValue(String locale, String value) {
    if (value.equals("r")) {
      if (local.equals("de")) {
        return "lesen";
      } else {
        return "read";
      }
    }

    if (value.equals("w")) {
      if (local.equals("de")) {
        return "schreiben";
      } else {
        return "write";
      }
    }

    if (value.equals("rw")) {
      if (local.equals("de")) {
        return "lesen/schreiben";
      } else {
        return "read/write";
      }
    }
  }
</pre>
      </p>
          
      <p>
        
        Die Methode <code>isQualified()</code> erlaubt die Prüfung, ob ein bestimmtes
        Privacy-Level in einem Anderen enhalten ist. Beispielsweise ist das Privacy-Level 
        &quot;read&quot; in &quot;readwrite&quot; enthalten, nicht jedoch umgehrt. 
        Dazu werden zwei Parameter übergeben. Anschließend erfolgt die Prüfung, 
        ob das durch den ersten Parameter dargestellte Privacy-Level in dem 
        Privacy-Level, das als zweiter Parameter übergeben wird, enthalten ist.
        <hr />
        Stimmt das so? Noch zu prüfen!
        <hr />
<pre>

  public boolean isQualified(String reference, String value) {

    // Abbrechen, wenn einer der Parameter null ist
    if (reference == null || value == null) {
      return false;
    }

    // &quot;lesen&quot; und &quot;schreiben&quot; sind im Privacy-Level &quot;lesen und schreiben&quot; enthalten
    if (value.equals(&quot;rw&quot;) {
      return true;
    }
    
    // Alle Privacy-Levels sind in sich selbst enthalten
    if (value.equals(reference)) {
      return true;
    }
  }
</pre>
      </p>
      <p>  
        Um dem Benutzer das <b>Ändern des Privacy-Levels</b> zu ermöglichen, wird in 
        &quot;changeValue()&quot; ein Dialog angezeigt, der alle verfügbaren Werte 
        des Privacy-Levels auflistet und dem Benutzer eine Auswahl darin ermöglicht.
        Um den aktuell verwendeten Wert hervorheben zu können, wird dieser der 
        Methode übergeben. Wurde durch den Benutzer ein Wert gewählt und damit der
        Dialog beendet, muss die Methoden den internen Namen des gewählten Werts 
        zurückgeben.
      </p>          
      
      <h3 id="devres_resgroup">Erstellen einer Ressourcengruppe</h3>
      <p>
        Die erstellten Ressourcen müssen einer Ressourcengruppe hinzugfügt werden. 
        Hierzu wird eine neue Klasse erstellt, die die Klasse &quot;ResourceGroup&quot; 
        erweitert. Die Klasse &quot;ResourceGroup&quot; besitzt einige abstrakte 
        Methoden die implentiert werden müssen.
      </p>
      <p>
        Die zwei Methoden <code>getName()</code> und <code>getDescription()</code> 
        liefern dem Anwender den <b>Namen</b> der Ressourcengruppe und eine 
        <b>Beschreibung</b> dieser. Die Metohden ähneln den gleichnamigen Methoden 
        der Klasse <code>PrivacyLevel</code> und erhalten den gleichen Parameter 
        (Sprache in ISO-639 Norm). Es empfiehlt sich auch hier, den Parameter zu
        ignorieren und statt dessen den Namen bzw. die Beschreibung aus der 
        String-Ressource zu laden.
      </p>
      <p>
        Damit Anwendungen auf die Ressourcengruppe zugreifen können, muss der <b>Name 
        des Services</b>, innerhalb dessen die Ressourcegruppe ausgeführt wird, 
        von der Gruppe geliefert werden können.
        Hierzu dient die Methode<code>getServiceAndroidName()</code>. Der von dieser 
        Methode gelieferte Wert muss mit der Angabe in der Android-Manifest-Datei 
        übereinstimmen. Andernfalls ist ein Zugriff auf die Gruppe nicht möglich.
      </p>

      <p>
        Um auf eine <b>erfolgreiche oder fehlgeschlagene Registierung</b> der 
        Ressourcengruppe in der PMP reagieren zu können, stehen die beiden 
        Callback-Methoden <code>onRegistrationSuccess()</code> und 
        <code>onRegistrationFailed()</code> zur Verfügung. <code>onRegistrationSuccess()</code> 
        wird aufgerufen nachdem die Registrierungsanfrage der Ressourcengruppe von
        der PMP erfolgreich bearbeitet wurde. Wurde <code>onRegistrationFailed()</code> 
        vom System aufgerufen, konnte die Gruppe dem System nicht hinzugefügt werden. 
        Über den String-Parameter wird der Grund des Fehlschlags übermittelt.
      </p>
      
<pre>
public class FileSystemResourceGroup extends ResourceGroup {

  public static final String SERVICE_NAME = 
                      "de.unistuttgart.ipvs.pmp.resources.FileSystemService";

  private final Context context;


  public FileSystemResourceGroup(Context context) throws Exception {
    super(context);

    // Store the service' context, because we will need it later
    this.context = context;
    
    ...
  }

  @Override
  public String getName(String locale) {
    return context.getResources().getString(R.string.rg_name);
  }

  @Override
  public String getDescription(String locale) {
    return context.getResources().getString(R.string.rg_desc);
  }

  @Override
  protected String getServiceAndroidName() {
    return SERVICE_NAME;
  }

  @Override
  public void onRegistrationSuccess() {
    // To keep it simple, we just make a log and tell the user that
    // everything went fine
    Log.d("Registration was successfull");

    try {
      Toast toast = Toast.makeText(context,
          "Registration successfull", Toast.LENGTH_SHORT);
      toast.show();
    } catch (Throwable t) {
      Log.d("Could not show toast-notification.", t);
    }
  }

  @Override
  public void onRegistrationFailed(String message) {
    // As in "onRegistrationSuccess()", we make a log and tell the user what
    // had happened
    Log.d("Registration failed: " + message);

    try {
      Toast toast = Toast.makeText(context,
          "Registration failed. PMP says: " + message,
          Toast.LENGTH_SHORT);
      toast.show();

    } catch (Throwable t) {
      Log.d("Could not show toast-notification.", t);
    }
  }

}
</pre>
      
      <h3 id="devres_addres">Hinzufügen der Resourcen zur Gruppe</h3>
      <p>
        Innerhalb der erstellten Ressourcen-Gruppe werden durch Aufruf der 
        Methode <code>registerResource()</code> die erstellten Ressourcen der 
        Gruppe zu geordnet. Damit später auf die einzelnen Ressourcen zugreifen
        zu können, wird neben der Referenz auf die Ressource eine String-Kürzel
        übergeben. Dieses Kürzel sollte in eine Konstante ausgelagert werden um
        Fehler beim Zugriff durch Tipp-Fehler oder einen veränderten Wert auszuschließen.
      </p>
      <p>
        Beinhaltet die Gruppe sehr viele Ressourcen, sollte über eine Auslagerung
        der Ressourcen-Instanzierung und der String-Konstanten in eine seperate
        Klasse nachgedacht werden.
      </p>
      
<pre>
public class FileSystemResourceGroup extends ResourceGroup {  
  ...
  public static final String RESOURCE_ONE = "resOne";
  public static final String RESOURCE_TWO = "resTwo";   
  ...

  public FileSystemResourceGroup(Context context) throws Exception {
    super(context);        
    ...
    registerResource(RESOURCE_ONE, new ResourceOne());
    registerResource(RESOURCE_TWO, new ResourceTwo());
    ...
  }
  ...
}
</pre>
      
      <h3 id="devres_addres">Hinzufügen der Privacy-Levels zur Gruppe</h3>
      <p>
        Ähnlich der Ressourcen werden die erstellten Privacy-Levels durch
        <code>registerPrivacyLevel()</code> der Gruppe hinzugefügt.
        Auch hier wird zur späteren Referenzierung ein String-Kürzel mit angegeben, das
        ebenfalls in eine Konstante ausgelagert werden sollte.  
      </p>
      <p>
        Da eine Gruppe viele Pirvacy-Levels enthalten kann, kann auch hier eine
        Auslagerung der Objekt-Instanzierung in eine eigene Klasse sinnvoll sein.
      </p>
<pre>
public class FileSystemResourceGroup extends ResourceGroup {  
  ...
  public static final String PL_ONE = "plOne";
  public static final String PL_TWO = "plTwo";   
  ...

  public FileSystemResourceGroup(Context context) throws Exception {
    super(context);        
    ...
    registerResource(PL_ONE, plOne);
    registerResource(PL_TWO, plTwo);
    ...
  }
  ...
}
</pre>
      <h3 id="devres_app">Erstellen der Anwendung</h3>
      <p>
        Um die Ressourcen-Gruppen auf eine Smartphone installieren zu können, wird eine 
        Anwendung benötigt, die die Ressourcen-Gruppen kapselt.
        Einer Anwendung kann mehrere Gruppen enthalten, d. h. es können mehrere
        Gruppen gemeinsam ausgeliefert und installiert werden.
      </p>
      <p>
        Als Basis der Anwendung wird die Klasse <code>ResourceGroupApp</code> erweitert.
        Für Anwendungen, die nur aus einer Ressourcen-Gruppe bestehen, bietet die 
        API mit der Klasse <code>ResourceGroupSingleApp</code> eine vereinfachte 
        Basis-Klasse. Diese implementiert bereits alle grundlegenden Funktionen,
        so dass das erstellen der Anwendung stark vereinfacht wird. 
      </p>
      <p>
        Bei Verwendung von <code>ResourceGroupSingleApp</code> wird lediglich die 
        Methode <code>createResourceGroup</code> implementiert. Diese muss lediglich 
        eine Refernz auf die erstellte Ressourcen-Gruppe zurückliefern.
      </p>
    </div>
    <!-- // end of specification's content -->
  </div>
</body>
</html>