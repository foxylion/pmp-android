f<!DOCTYPE html>
<html>
<head>
  <title>Handbuch - Privacy Management Platform</title>
  <script type="text/javascript" src="../_layout/jquery-1.6.2.min.js"></script>
  <script type="text/javascript" src="../_layout/script.js"></script>
  <link type="text/css" rel="stylesheet" media="screen" href="../_layout/style.css">
  <link type="text/css" rel="stylesheet" media="print"  href="../_layout/print.css">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
  <div id="wrapper">
    <div id="page-head-date">24. September 2011</div>
    <div id="page-head-title">Privacy Management Platform</div>
    <div id="page-title">Handbuch</div>
    <div id="page-version">Version 0.2</div>
    
    <nav>
      <div class="title">Inhaltsverzeichnis</div>
      <ul>
      </ul>
    </nav>
    
    <!-- here comes the content of the specification -->
    <div id="content">
      
      <h1 id="einleitung">Einleitung</h1>
      
      <h2 id="zweck">Zweck</h2>
      <p>
        Dieses stellt das Handbuch der "Privacy Management Platform". Es soll
        sowohl den Laien als auch den erfahrenen Benutzer und Entwickler bei der
        Verwendung der PMP unterstützen. Auf eine gute Verständlichkeit wird
        Wert gelegt.        
      </p>
      
      <h2 id="leserkreis">Leserkreis</h2>
      <p>
        Das Handbuch richtet sich an folgende Lesergruppen:
        <ul>
          <li>den unerfahrenen Benutzer</li>
          <li>den erfahrenen Benutzer</li>
          <li>den Entwicklern von Ressourcen (für die PMP)</li>
          <li>den Entwicklern von Applikationen inkl. deren Service-Levels</li>
          <li>dem Kunden</li>
          <li>den Betreuern des Studienprojekts</li>
        </ul> 
      </p>
      
      
      <h2 id="gliederung">Gliederung</h2>
      <p>
        Der besseren Übersicht wegen unterteilt sich das Handbuch in die einzelnen
        Benutzergruppen:
        <ul>
          <li>"<span class="reference" title="#user"></span>" richtet sich an Benutzer,
            die die PMP verwenden möchten. Dieses Kapitel enthält eine Beschreibung aller
            im einfachen Modus (<span class="reference" title="#simplemode"></span>) 
            verfügbaren Funktionen, sowie eine Beschreibung der Funktionen, die 
            erst im erweiterten Modus (<span class="reference" title="#expertmode"></span>)
            verfügbar sind.</li>
          <li>"<span class="reference" title="#developers"></span>" richtet sich an 
            Benutzer, die Ressourcen oder Apps für die PMP entwickeln möchten.
            Der Unterabschnitt "<span class="reference" title="#devres"></span>"
            geht auf die Erstellung von Ressourcen ein. Dagegen beschriebt           
            "<span class="reference" title="#devsl"></span>"
            wie Service-Levels definiert und in eigene Applikationen integriert werden können.
        </ul>
      </p>
      
      <h1 id="basics">Grundbegriffe</h1>
      <p>
        Dieser Abschnitt erläutert einige Grundbegriffe die im Kontext der PMP
        verwendet werden.
      </p>
      
      <h2 id="basisc_res">Ressourcen</h2>
      <p>
        Ressourcen bieten Anwendungen Zugriff auf die verschiedenen Funktionen eines 
        Android-Gerätes. In der PMP werden einzelne, inhaltlich zusammengehörige 
        Ressourcen in Ressourcengruppen zusammengefasst. Diese Gruppen könne dann auf dem Gerät
        installiert werden.
      </p>
      <p>
        Jede Ressourcengruppe definiert mehrere sogenannte Privacy-Levels. Diese
        können verschiedene Werte zugewiesen werden (etwa erlauben oder nicht).
        Abhängig vom gesetzten Wert ist ein Zugriff auf eine Funktion der Ressource
        möglich (ist etwa des Privay-Level "Datei lesen" gesetzt, das
        Level "Datei schreiben" jedoch nicht, so erlaubt die Ressource nur das
        Auslesen einer Datei, nicht jedoch das Schreiben in eine Datei).
      </p>
       
      <h2 id="basics_sl">Service-Level</h2>
      <p>
        Jede PMP-Applikation legt fest, welche Funktionen bestimmter Ressourcen 
        sie benötigt und welche Dienste sie hierfür dem Benutzer anbietet. Diese 
        Vereinbarung wird als Service-Level bezeichnet. Eine Applikation besitzt
        in der Regel mehrere Service-Levels.
      </p>
      <p>
        Im Detail legt jedes Service-Level fest, welche Ressourcengruppen benötigt 
        werden, und auf welchen Wert die zur Gruppe gehörigen Privacy-Levels 
        gesetzt werden müssen. Wird ein Service-Level gewählt, so werden die
        Privacy-Levels auf die festgelegten Werte gesetzt, wodurch Zugriffe auf
        die zugehörigen Funktionen der Ressourcen möglich sind.
      </p>
      <p>
        Das niedrigste Service-Level, das PMP-Applikationen stets anbieten, erlaubt
        diesen keinerlei Zugriff auf Ressourcen und damit auf kritische Bereiche
        des Geräts.
      </p>
      
      <h1 id="user">Anwender</h1>
      <p>
        Dieser Abschnitt richtet sich an die Benutzer der PMP.
      </p>
        
      <h2 id="modes">Anwender-Modis</h2>
      <p>
        Die PMP lässt sich in
        zwei Modi betreiben: im einfachen Modus (als Simple Mode bezeichnet), stehen
        dem Benutzer die wichtigsten Funktionen zur Verfügung. Werden alle Funktionen
        benötigt, lässt sich das System in den erweiterten Modus (Expert Mode) schalten.
      </p>
      
      <h3 id="switchmode">Modus-Wechsel</h3>
      <p>
        Der Wechsel zwischen einfachem und erweitertem Modus erfolgt über die 
        Schaltfläche "Expert Mode" auf dem Startbildschirm der PMP.
      </p>
      <p>
        Befindet sich die PMP im erweiterten Modus, erscheint ein Häkchen im vorderen
        Bereich der Schaltfläche. Durch Antippen der Schaltfläche wird zwischen 
        den Modi hin- und her gewechselt.
      </p> 
      
      <h3 id="simplemode">Einfacher Modus (Simple Mode)</h3>
      <p>
        Der einfache Modus ist auf Anwender mit geringen Kenntnissen angepasst.
        Daher enthält er nur die wichtigsten Funktionen um den Benutzer nicht zu 
        überfordern.
      </p>
      
       
      <h3 id="expertmode">Erweiterter Modus (Expert Mode)</h3>
      <p>
        Der erweiterte Modus gibt Zugriff auf alle Funktionen der PMP. Da sich daher 
        unerfahrene Benutzer überfordert fühlen könnten, richtet sich dieser Modus
        an erfahrene Benutzer, die vollen Zugriff auf den Funktionsumfang haben möchten.
      </p>
      <p>
        Die Abgrenzung zwischen den beiden Modi erfolgt in der nachfolgenden 
        Beschreibungen durch Hinweise der Form "Expert Mode:". Die diesem 
        Hinweis folgenden Funktionen sind ausschließlich im erweiterten
        Modus verfügbar.
      </p>
      <p>
        Da der erweiterte Modus gegenwärtig nicht implementiert ist, wird auf ihn 
        in dieser Version des Handbuchs nicht näher eingegangen.
      </p>
      
      <!-- 12:18 -->
      <h2 id="apps">Applikationen</h2>
      <h3 id="apps_inst">Applikationen installieren</h3>
      <p>
        Die Installation von PMP-Applikationen unterscheidet sich nicht von
        der Installation gewöhnlicher Applikationen. Im Allgemeinen benötigen
        PMP-Applikationen selbst keine Zugriffsrechte auf System-Funktionen, da
        diese Zugriffe über die PMP-Ressourcen erfolgen.
      </p>
            
      <h3 id="apps_uninst">Applikationen deinstallieren</h3>
      <p>
        Da PMP-Applikationen in Bezug auf die Installation gegenüber anderen
        Applikationen keine Sonderstellung einnehmen, werde sie auch auf gleicher
        Weiße deinstalliert.
      </p>
      
      <h3 id="apps_sl">Service-Levels einstellen, installierte Anwendungen anzeigen</h3>
      <p>
        Beim ersten Start der Applikation werden alle von ihr angebotenen
        Service-Levels angezeigt. Nach Auswahl des gewünschten Service-Levels
        erhält die Applikation Zugriff auf die darin festgelegten Ressourcen und
        deren Funktionen.
      </p>
      <p>
        Das gewählte Service-Level lässt sich jederzeit über die Benutzeroberfläche
        der PMP ändern. Durch Antippen der ersten Schaltfläche "Apps" im Hauptmenü
        der PMP werden alle installierten PMP-Applikationen aufgelistet. Anschließend
        kann durch Auswahl einer Applikation deren Service-Level festgelegt werden.
      </p>
      
      <h2 id="res">Ressourcen</h2>
      <h3 id="res_inst">Ressourcen installieren</h3>
      <p>
        PMP-Ressourcen werden in Form einer Andorid-Applikation, einer apk-Datei,
        ausgeliefert. Hierdurch unterscheidet sich die Installation von PMP-Ressourcen
        nicht von der Installation gewöhnlicher Andorid-Applikationen:
        Übertragen Sie die apk-Datei auf Ihr Gerät und öffnen Sie diese
        oder wählen Sie die Ressource aus dem App-Store aus. Folgen Sie anschließend
        den Anweisungen des Andorid-Betriebssystems. Damit die Ressource lauffähig ist,
        müssen die von dieser verlangten Zugriffsrechte genehmigt werden.
      </p>
      
      <h3 id="res_uninst">Ressourcen deinstallieren</h3>
      <p>
        Wie bereits unter "<span class="reference" title="#res_inst"></span>" erwähnt,
        werden PMP-Ressourcen wie gewöhnliche Andorid-Applikationen ausgeliefert
        und installiert. Daher erfolgt auch die Deinstallation wie bei normalen
        Android-Applikationen: Wechseln Sie in die Anwendungsverwaltung von
        Android (Launcher -> "Settings" -> "Manage Applications" (TODO: verifizieren)) 
        und wählen Sie die Ressource aus, die sie deinstallieren möchten. Klicken
        Sie anschließend auf "Uninstall" und betätigen Sie die Sicherheitsabfrage.
      </p>
      
      <h3 id="res_show">Installierte Ressourcen anzeigen</h3>
      <p>
        Über die zweite Schaltfläche "Resources" im Hauptmenü der PMP lassen sich 
        alle gegenwärtig auf dem Gerät installierten PMP-Ressourcen anzeigen.
        Durch Antippen einer Ressource werden weitere Informationen über diese
        angezeigt.
      </p> 
      
     
      <h1 id="developers">Entwickler</h1>
      <p>
        Dieser Abschnitt richtet sich an erfahrene Benutzer, die die PMP um eigene
        Ressourcen erweitern oder Anwendungen für die PMP erstellen möchten
      </p>
      
      
      <h2 id="devres">Ressourcen</h2>
      <p>
        Das Erstellen einer Ressourcengruppe und deren Ressourcen gliedert sich 
        in folgende Schritten:
        <ul>
          <li>Bestimmen und Implementieren einzelner Ressourcen (z. B. jeweils eine 
            Ressource um eine Datei in verschiedenen Bereichen des Geräts zu lesen, 
            schreiben oder zu löschen)</li>
          <li>Festlegen einer Ressourcengruppe (z. B. Dateisystemzugriff) und Hinzufügen 
            der erstellten Ressourcen zu dieser</li>
          <li>Bestimmen und Implementieren der zu der erstellten Ressourcengruppe
            passenden Privacy-Levels (z. B. nur lesen, nur schreibe oder lesen und 
            schreiben)</li>
          <li>Hinzufügen der Privacy-Levels zu der Ressourcengruppe</li>
          <li>Implementieren einer Anwendung, die die erstellten Ressourcengruppen 
            enthält.</li>
        </ul>
        In den nachfolgenden Unterabschnitten werden die einzelnen Phasen genauer
        beschrieben und anhand von Beispielen erläutert.<br /> 
        Alle für das Erstellen einer Ressource benötigten Klassen befinden sich im 
        Paket &quot;de.unistuttgart.ipvs.pmp.resource&quot; der API-Bibliothek.<br />
        Der PMP liegen mehrere Beispiel-Ressourcen bei. Diese können als Referenz 
        für das Erstellen eigener Ressourcen verwendet werden.
      </p>
      
      <h3 id="devres_res">Erstellen einer Ressource</h3>
      <p>
        Ressourcen bilden die Grundlage einer Ressourcengruppe. Jede Gruppe benötigt 
        mindestens eine Ressourcen. Die Basisklasse einer Ressource bildet 
        <code>Resource</code>.
        Um eigene Ressourcen zu erstellen, wird diese erweitert. Anschließend muss 
        die Methode <code>getAndroidInterface()</code> impelementiert werden.
      </p>

      <p>
        Zunächst wird eine AIDL-Interace erstellt, dass die für Anwendungen sichtbaren 
        Funktionen der Ressource beinhaltet (etwa Datei lesen). Nachdem das Android-SDK aus 
        diesem Interface automatisch ein Stub erstellt hat, wird dieses implementiert, 
        um die Funktionalität der Ressource zu liefern.
        Die Aufgabe der Methode <code>getAndroidInterface()</code> besteht nun ausschließlich
        darin, die Implementierung dieses Interface zurück zu geben, um hierdurch
        Anwendungen Zugriff auf die Funktionen der Ressource zu bieten. 
        Über den Parameter wird der Name der Anwendung übergeben, die Zugriff auf 
        die Funktionen der Ressource verlangt. Dieser sollte an die Implementierung des
        AIDL-Interface weitergereicht werden, damit diese prüfen kann, ob die 
        Anwendung zum Zugriff auf die einzelnen Funktionen berechtigt ist.
      </p>
      
      <h3 id="devres_privlevel">Erstellen eines Privacy-Levels</h3>
      <p>
        Jede Ressourcengruppe beinhaltet mehrere Privacy-Levels. Privacy-Levels 
        werden durch Erweitern der Klasse <code>PrivacyLevel</code> erstellt, wobei 
        alle abstrakten Methoden implementiert werden müssen. Um den 
        Implementierungsaufwand zu verringern, bietet die API für häufige wiederkehrende
        Einsatzgebiete Standartimplementierungen an:
      </p>

      <h4 id="devres_privlevel_boolean">Für Wahrheitswerte</h4>
      <p>
        Wird ein Privacy-Level benötigt, das als Einstellungswert ausschließlich
        einen Wahrheitswert ("Ja"/"Nein") erlaubt (z. B. "lesen erlauben"), so
        sollte für das Privacy-Level die fertig implementierte Klasse 
        <code>BooleanPrivacyLevel</code> verwendet werden. Bei der Instanziierung
        erwartet der Konstruktor als Parameter den Namen des Privacy-Levels
        und als weiteren Parameter eine Beschreibung. Hierbei empfiehlt es sich,
        den Namen und die Beschreibung des Privacy-Levels in die String-Ressource
        auszulagern, um die Internationalisierung zu vereinfachen.
      </p>
      
<pre>
Resource r = context.getResources();
plOne = new BooleanPrivacyLevel(r.getString(R.string.pl_one), 
          r.getString(R.string.pl_one_desc));
plTwo = new BooleanPrivacyLevel(r.getString(R.string.pl_two), 
          r.getString(R.string.pl_two_desc));
</pre>

      <h4 id="devres_privlevel_userdefined">Benutzerdefiniert</h4>      
      <p>
        Sollte die Erstellung eine benutzerdefinierten Privacy-Levels erforderlich
        sein, d. h. das Privacy-Level lässt sich nicht durch eine bestehenden
        Implementierung realisieren, so lässt sich ohne weiteres ein eigenes
        Privacy-Level implementieren. Hierzu muss die Klasse 
        <code>PrivacyLevel</code> erweitert und ihre abstrakten Methoden
        implementiert werden. Eine Liste aller zu implementierenden Methoden und
        deren Aufgaben entnehmen Sie bitte der API-Dokumentation.
      </p>
      <!--
      HINWEIS: Da die API im Moment nicht fix ist, d.h. sich schon ein paarmal
      verändert hat, habe ich mich für einen Verweis auf die API-Doku entschieden.
      
      <p>
        Über <code>getName()</code> und <code>getDescription()</code> erhält der 
        Anwender den <b>Namen</b> und die <b>Beschreibung</b> des Privacy-Levels. 
        Beide Methoden erhalten als Parameter das Kürzel der Sprache, in der der 
        jeweilige Wert zurückgegeben werden soll, wobei der Parameter der ISO-639 
        Norm entspricht (z.B. &quot;en&quot; bei englisch, &quot;de&quot; bei deutsch).
        Die Methoden müssen anschließen den zur jeweiligen Sprache gehörenden Wert 
        zurück liefern. Es epmfiehlt sich allerdings den Parameter zu ignorieren
        und stets den entsprechenden Werte aus der String-Ressource zu laden.
      </p>

      <p>
        Über die Methode <code>getHumanReadablePrivacyLevelValue()</code> 
        wird der <b>menschen lesbare Wert eines Privacy-Levels</b> zurückgegeben. 
        Der erste Parameter entspricht dem oben erwähnten Sprachlkürzel.
        Dieser gibt an, in welcher Sprache der Wert zurückgeliefert werden soll. 
        Über den zweiten Wert wird der intern verwendete Wert des Privacy-Levels 
        übergeben. Aus diesen Daten berechnet die Methode den für die Anzeige
        geeigneten Text (z. B. wird aus dem internen Wert "r" und der gewählten 
        Sprache "de" der Text "lesen" berechnet und zurückgegeben).
        Wie bereits oben erwähnte, empfiehlt es sich auch hier, die String-Ressourcen
        zu verwenden.
      </p>
        
<pre>
  public String getHumanReadablePrivacyLevelValue(String locale, String value) {
    if (value.equals("r")) {
      if (local.equals("de")) {
        return "lesen";
      } else {
        return "read";
      }
    }

    if (value.equals("w")) {
      if (local.equals("de")) {
        return "schreiben";
      } else {
        return "write";
      }
    }

    if (value.equals("rw")) {
      if (local.equals("de")) {
        return "lesen/schreiben";
      } else {
        return "read/write";
      }
    }
  }
</pre>
      </p>
          
      <p>
        
        Die Methode <code>isQualified()</code> erlaubt die Prüfung, ob ein bestimmtes
        Privacy-Level in einem Anderen enhalten ist. Beispielsweise ist das Privacy-Level 
        &quot;read&quot; in &quot;readwrite&quot; enthalten, nicht jedoch umgehrt. 
        Dazu werden zwei Parameter übergeben. Anschließend erfolgt die Prüfung, 
        ob das durch den ersten Parameter dargestellte Privacy-Level in dem 
        Privacy-Level, das als zweiter Parameter übergeben wird, enthalten ist.
        <hr />
        Stimmt das so? Noch zu prüfen!
        <hr />
<pre>

  public boolean isQualified(String reference, String value) {

    // Abbrechen, wenn einer der Parameter null ist
    if (reference == null || value == null) {
      return false;
    }

    // &quot;lesen&quot; und &quot;schreiben&quot; sind im Privacy-Level &quot;lesen und schreiben&quot; enthalten
    if (value.equals(&quot;rw&quot;) {
      return true;
    }
    
    // Alle Privacy-Levels sind in sich selbst enthalten
    if (value.equals(reference)) {
      return true;
    }
  }
</pre>
      </p>
      <p>  
        Um dem Benutzer das <b>Ändern des Privacy-Levels</b> zu ermöglichen, wird in 
        &quot;changeValue()&quot; ein Dialog angezeigt, der alle verfügbaren Werte 
        des Privacy-Levels auflistet und dem Benutzer eine Auswahl darin ermöglicht.
        Um den aktuell verwendeten Wert hervorheben zu können, wird dieser der 
        Methode übergeben. Wurde durch den Benutzer ein Wert gewählt und damit der
        Dialog beendet, muss die Methoden den internen Namen des gewählten Werts 
        zurückgeben.
      </p>    
      -->      
      
      <h3 id="devres_resgroup">Erstellen einer Ressourcengruppe</h3>
      <p>
        Die erstellten Ressourcen müssen einer Ressourcengruppe hinzugefügt werden. 
        Hierzu wird eine neue Klasse erstellt, die die Klasse <code>ResourceGroup</code> 
        erweitert. Die Klasse <code>ResourceGroup</code> besitzt einige abstrakte 
        Methoden die implementiert werden müssen.
      </p>
      <p>
        Die zwei Methoden <code>getName()</code> und <code>getDescription()</code> 
        liefern dem Anwender den <b>Namen</b> der Ressourcengruppe und eine 
        <b>Beschreibung</b> dieser. Zwar wird den Methoden im Parameter die
        Benutzersprache mit übergeben (ISO-639 Norm), aus Gründen der 
        Internationalisierbarkeit sollte dieser jedoch ignoriert werden und 
        statt dessen der Namen bzw. die Beschreibung aus der String-Ressource geladen
        werden.
      </p>
      <p>
        Damit Anwendungen auf die Ressourcengruppe zugreifen können, muss der <b>Name 
        des Services</b>, innerhalb dessen die Ressourcengruppe ausgeführt wird, 
        von der Gruppe geliefert werden können.
        Hierzu dient die Methode <code>getServiceAndroidName()</code>, die diesen 
        Namen liefert. Wichtig ist hierbei, dass der von dieser 
        Methode gelieferte Wert mit der Angabe in der Android-Manifest-Datei 
        übereinstimmen. Andernfalls ist ein Zugriff auf die Gruppe nicht möglich.     
        Wichtig ist, dass sich in der Manifest-Datei dieser Name auf den Service
        <code>de.unistuttgart.ipvs.pmp.service.resource.ResourceGroupService</code>
        bezieht (siehe unten stehendes Beispiel).
      </p>

      <p>
        Um auf eine <b>erfolgreiche oder fehlgeschlagene Registrierung</b> der 
        Ressourcengruppe in der PMP reagieren zu können, stehen die beiden 
        Callback-Methoden <code>onRegistrationSuccess()</code> und 
        <code>onRegistrationFailed()</code> zur Verfügung. <code>onRegistrationSuccess()</code> 
        wird aufgerufen nachdem die Registrierungsanfrage der Ressourcengruppe von
        der PMP erfolgreich bearbeitet wurde. Wurde <code>onRegistrationFailed()</code> 
        vom System aufgerufen, konnte die Gruppe dem System nicht hinzugefügt werden. 
        Über den String-Parameter wird der Grund des Fehlschlags übermittelt.
      </p>
      <h4 id="devres_resgroup_example">Beispiel</h4>
      <p>
        Unter Berücksichtigung des oben Erwähnten, könnte eine Ressourcengruppe
        wie folgt aussehen:
      
<pre>
public class FileSystemResourceGroup extends ResourceGroup {

  public static final String SERVICE_NAME = 
                      "de.unistuttgart.ipvs.pmp.resources.FileSystemService";

  private final Context context;


  public FileSystemResourceGroup(Context context) throws Exception {
    super(context);

    // Store the service' context, because we will need it later
    this.context = context;
    
    ...
  }

  @Override
  public String getName(String locale) {
    return context.getResources().getString(R.string.rg_name);
  }

  @Override
  public String getDescription(String locale) {
    return context.getResources().getString(R.string.rg_desc);
  }

  @Override
  protected String getServiceAndroidName() {
    return SERVICE_NAME;
  }

  @Override
  public void onRegistrationSuccess() {
    Log.d("Registration was successfull");
  }

  @Override
  public void onRegistrationFailed(String message) {
    Log.d("Registration failed: " + message);
  }

}
</pre>
      </p>
      <p>
        Die zugehörige Manifest-Datei:
<pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;manifest ...>
  ...
  &lt;application ...>
    ...
    &lt;activity android:label="@string/app_name" android:name="de.unistuttgart.ipvs.pmp.resource.ResourceGroupActivity">
	    &lt;intent-filter>
	      &lt;action android:name="android.intent.action.MAIN" />
	      &lt;category android:name="android.intent.category.LAUNCHER" />
      &lt;/intent-filter>
    &lt;/activity>
    
    &lt;service android:exported="true" android:name="de.unistuttgart.ipvs.pmp.service.resource.ResourceGroupService">
      &lt;intent-filter>
        &lt;action android:name="de.unistuttgart.ipvs.pmp.resourcegroups.switches"></action>
      &lt;/intent-filter>
    &lt;/service>
    ...
  &lt;/application>  
&lt;/manifest>
</pre>
      
      <h3 id="devres_addres">Hinzufügen der Ressourcen zur Gruppe</h3>
      <p>
        Innerhalb der erstellten Ressourcengruppe werden durch Aufruf der 
        Methode <code>registerResource()</code> die erstellten Ressourcen der 
        Gruppe zugeordnet. Um einen späteren Zugriff auf die einzelnen Ressourcen 
        zu ermöglichen, wird neben der Referenz auf die Ressource noch eine String-Kürzel
        mit übergeben. Dieses Kürzel sollte in eine Konstante ausgelagert werden um
        Fehler beim Zugriff durch Tipp-Fehler oder einen veränderten Wert auszuschließen.
        Es muss darauf geachtet werden, dass das String-Kürzel eindeutig ist.
        Eine bereits registrierte Ressource wird überschrieben, sollte eine
        Ressource mit gleichem Kürzel hinzugefügt werden.
      </p>
      <p>
        Beinhaltet die Gruppe sehr viele Ressourcen, sollte über eine Auslagerung
        der Ressourcen-Instanziierung und der String-Konstanten in eine separate
        Klasse nachgedacht werden.
      </p>
      
<pre>
public class FileSystemResourceGroup extends ResourceGroup {  
  ...
  public static final String RESOURCE_ONE = "resOne";
  public static final String RESOURCE_TWO = "resTwo";   
  ...

  public FileSystemResourceGroup(Context context) throws Exception {
    super(context);        
    ...
    registerResource(RESOURCE_ONE, new ResourceOne());
    registerResource(RESOURCE_TWO, new ResourceTwo());
    ...
  }
  ...
}
</pre>
      
      <h3 id="devres_addres">Hinzufügen der Privacy-Levels zur Gruppe</h3>
      <p>
        Ähnlich der Ressourcen werden die erstellten Privacy-Levels durch
        <code>registerPrivacyLevel()</code> der Gruppe hinzugefügt.
        Auch hier wird zur späteren Referenzierung ein String-Kürzel mit angegeben, das
        ebenfalls in eine Konstante ausgelagert werden sollte und eindeutig sein
        muss.  
      </p>
      <p>
        Da eine Gruppe viele Privacy-Levels enthalten kann, kann auch hier eine
        Auslagerung der Objekt-Instanziierung in eine eigene Klasse sinnvoll sein.
      </p>
<pre>
public class FileSystemResourceGroup extends ResourceGroup {  
  ...
  public static final String PL_ONE = "plOne";
  public static final String PL_TWO = "plTwo";   
  ...

  public FileSystemResourceGroup(Context context) throws Exception {
    super(context);        
    ...
    registerResource(PL_ONE, plOne);
    registerResource(PL_TWO, plTwo);
    ...
  }
  ...
}
</pre>
      <h3 id="devres_app">Erstellen der Anwendung</h3>
      <p>
        Um die Ressourcengruppen auf einem Gerät installieren zu können, wird eine 
        Anwendung benötigt, die die Ressourcengruppen kapselt.
        Eine Anwendung kann mehrere Gruppen enthalten, d. h. es können mehrere
        Gruppen gemeinsam ausgeliefert und installiert werden.
      </p>
      <p>
        Als Basis der Anwendung wird die Klasse <code>ResourceGroupApp</code> erweitert.
        Für Anwendungen, die nur aus einer Ressourcengruppe bestehen, bietet die 
        API mit der Klasse <code>ResourceGroupSingleApp</code> eine vereinfachte 
        Basis-Klasse an. Diese implementiert bereits alle grundlegenden Funktionen,
        so dass das Erstellen der Anwendung stark vereinfacht wird. 
      </p>
      <p>
        Bei Verwendung von <code>ResourceGroupSingleApp</code> muss lediglich die 
        Methode <code>createResourceGroup</code> so implementiert werden, dass diese
        eine Referenz auf die erstellte Ressourcengruppe zurückliefern.
      </p>
      <p>
        Soll die Anwendung mehrere Ressourcengruppen enthalten, ist eine
        Implementierung der abstrakten Klasse <code>ResourceGroup</code> unumgänglich.
        Informationen über die zu implementierenden Methoden finden Sie in der
        API-Dokumentation.
      </p>
      
      <h2 id="devsl">Service-Levels</h2>
      <p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</p>
      
      
      <h1 id="versions">Versionshistorie</h1>
      <h3>Version 0.2 (24.09.2011)</h3>
			<ul>
			  <li>Kapitel zu Grundbegriffen hinzugefügt</li>
		  </ul>
		  
      <h3>Version 0.1 (20.09.2011)</h3>
			<ul>
			  <li>Kapitel zur Ressourcen-Entwicklung fertiggestellt</li>
		  </ul>
    </div>
    <!-- // end of specification's content -->
  </div>
</body>
</html>